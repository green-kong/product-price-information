
# 스프링부트 버전 3.2.3을 사용하고 있습니다. 자바 17 이상에서만 빌드가 가능합니다.
# 설치된 자바 버전 또는 JAVA_HOME 환경변수에 따라 빌드가 되지 않을 수 있으니 확인 부탁드립니다.

# 프론트 서버 실행을 위해 npm 설치 여부를 확인 부탁드립니다.

# 실행

QA 중 서버 실행 및 종료 과정이 번거롭다 느껴져 `shell script`를 작성했습니다.
스크립트 최초 실행 이전에 실행 권한 설정이 필요합니다.

```sh
# 프로젝트 루트 디렉토리
chmod +x start.sh
chmod +x end.sh
```

## 실행
```sh
# 프로젝트 루트 디렉토리
./start.sh
```

스크립트 실행으로 프론트서버와 백엔드 서버가 모두 실행 됩니다.

여러번 테스트를 거쳐 정상 동작하는 것을 확인 했으나, 
스크립트가 정상적으로 동작되지 않는 경우는 다음과 같이 실행 가능합니다.

```sh
# 백엔드 서버 실행
# 프로젝트 루트 디렉토리
cd musinsa-server
./gradlew clean build
java -jar build/libs/musinsa-server-0.0.1-SNAPSHOT.jar

# 프론트 서버 실행
# 프로젝트 루트 디렉토리
cd musinsa-front
npm install
npm run dev
```

서버가 실행되면, [API 문서](http://localhost:8080/api/docs)를 확인할 수 있습니다.
프론트 접속 주소는 [http://localhost:5173](http://localhost:5173)입니다.

##  종료
```sh
# 프로젝트 로트 디렉토리
./end.sh
```

## 테스트
```
# 프로젝트 루트 디렉토리
cd musinsa-server
./gradlw test
```


# 요구사항

## 브랜드
- [x] 브랜드를 생성한다.
	- [x] 브랜드 이름은 1 글자 이상이어야 한다.
  - [x] 브랜드 이름은 중복 될 수 없다.
- [x] 생성 된 모든 브랜드를 조회한다.

## 카테고리
- [x] 카테고리를 생성한다.
	- [x] 카테고리의 이름은 2글자 이상이어야 한다.
  - [x] 브랜드 이름은 중복 될 수 없다.
- [x] 생성 된 모든 브랜드를 조회한다.

## 프로덕트
- [x] 상품을 생성한다.
	- [x] 존재하는 브랜드와 카테고리의 아이디를 포함해야 한다.
	- [x] 생성하는 가격의 최소가격은 10원, 최대 가격은 1,000,000원 이다.
- [x] 생성 된 모든 상품을 조회한다.
- [x] 생성 된 상품의 가격을 수정한다.
	- [x] 수정하는 가격의 최소가격은 10원, 최대 가격은 1,000,000원 이다.
	- [x] 존재하는 상품의 가격만 수정가능하다.
- [x] 생성 된 상품을 삭제한다.
	- [x] 존재하는 상품만 삭제 가능하다.

## 최소 / 최대 가격 정보
- [x] 특정 브랜드의 카테고리별 최저가격을 조회한다.
	- [x] 조회하려는 브랜드는 모든 카테고리의 상품이 존재해야 한다.
- [x] 특정 카테고리 별 최대 / 최소 가격 정보를 조회한다.
	- [x] 특정 카테고리의 최대 / 최소 가격 정보가 존재해야 한다.
- [x] 전체 상품 중 카테고리별 최저 가격 정보를 조회한다.
	- [x] 모든 카테고리의 상품의 가걱 정보가 존재해야 햔다.

- [x] 상품이 생성 / 수정 / 삭제 되는 경우 최소 / 최대 가격정보를 업데이트 한다.


# 구현 사항


## 가격 정보 기능

### 문제 

가장 먼저 떠오른 방식은 Product 테이블을 직접 조회하는 방식이었습니다.  
하지만 데이터의 양이 많을 경우 조회에 소요되는 시간이 길어질 것으로 예상하였습니다.  

이를 해결 하기 위해 캐시를 이용할 수도 있었지만, 캐시 유지 시간(TTL)에 따라  
어떤 사용자는 실시간으로 업데이트 되지 않은 가격정보를 받을 수도 있겠다는 생각이 들었습니다.  

예를 들어 캐시 유지시간이 60초인 경우, 최저가격의 상품인 A상품이 등록 되었으나,  
캐시 유지시간이 아직 남아있는 경우에 사용자가 최저가격 정보를 조회하는 상황을 생각해봤습니다.  
소비자는 A상품이 아닌 이전의 정보를 전달 받고 물건을 구매할 것이고,  
A상품을 등록한 판매자는 캐시 유지 기간 동안 최저가격정보의 자신의 상품이 노출 되지 않습니다.  
그렇기에 이러한 방식은 소비자와 판매자 모두에게 좋지 않은 사용경험이 될 수 있겠다는 생각을 했습니다.  

### 해결

이러한 상황을 해결하고자, 브랜드 + 카테고리 별로 최저 / 최고가격을 저장하고,  
상품의 생성 / 수정 / 삭제가 발생 할 시 가격정보를 저장하는 방식을 사용하였습니다.  

최저 가격 정보 테이블과 최고 가격 정보 테이블에는  
`최대 전체 브랜드 수 * 전체 카테고리 수` 만큼의 데이터만 저장 되기에  
전체 상품 목록에서 조회하는 것보다, 조회성능이 빠를 것으로 예상하였습니다.  

상품의 쓰기작업에 오버헤드가 발생하지만, 서비스 특성 상 쓰기 작업보다 읽기 작업의 비율이 압도적으로 높을 것으로 예상하여  
읽기 성능을 끌어올리는데 집중하였습니다.  

### 서비스 결합도

### 문제

상품의 쓰기 작업 이후 가격정보를 업데이트 하기 위해선 상품 서비스가 가격정보 서비스를 의존하게 됩니다.  
이는 서비스 결합도를 높여, 사이드 이펙트가 발생할 수 있습니다.  

### 해결

스프링 이벤트를 사용해 서비스 결합도를 낮췄습니다.  
상품이 생성 / 수정 / 삭제 될 시, 이벤트를 발행하고 가격 정보 서비스에서 리스닝 합니다.  

`@Async`를 상품 쓰기작업 트랜잭션과 가격정보 업데이트의 트랜잭션을 분리하고,  
사용자에게 조금 더 빠른 응답을 줄 수 있도록 하였습니다.  

그리고 상품 쓰기 작업이 정상적으로 완료된 시점에 가격 정보가 업데이트 되도록  
`@TransactionalEventListener(phase = AFTER_COMMIT)`을 사용했습니다.


## 테스트

평소에 테스트 코드의 중요성을 실감하고 있기에, 이번에도 테스트 코드를 꼼꼼하게 작성하려 노력하였습니다.  

<img width="570" alt="image" src="https://github.com/green-kong/musinsa-assignment/assets/96301958/29b8d2c2-4b57-47de-9db9-bc159134e6dd">


<img width="623" alt="image" src="https://github.com/green-kong/musinsa-assignment/assets/96301958/7e2573a7-ac36-4232-ac81-4fb0147b5309">


인수테스트를 포함하여 180개의 테스트를 작성 하였고 높은 커버리지를 달성하였습니다.
테스트를 통해 객체간의 협력을 확인 하는 것을 중요하게 여겨, 모킹은 최대한 배제하고 테스트 코드를 작성했습니다.

바운디드 컨텍스트 밖으로 빠져나가는 부분은 모킹을 하여 테스트를 진행했습니다.
예를 들어, 상품의 정보를 조회하는 기능은 `BrandLoader`  와 `CategoryLoader`  를 통해 카테고리 정보와 브랜드 정보를 불러와야 하는데 테스트에선 이를 모킹하였습니다.
현재는 리포지토리를 통한 조회로 다른 도메인의 정보를 불러오지만, 이후에 다른 도메인의 정보를 불러오는 방식이 변경되는 경우를 생각했습니다.

서비스간의 협력은 인수테스트를 통해 검증하였습니다. 인수테스트는 `Cucumber`를 이용하여 작성하였습니다.
<img width="701" alt="image" src="https://github.com/green-kong/musinsa-assignment/assets/96301958/26601e84-f3c4-4725-80b5-5b334cb3595e">

이번 과제를 통해 `Cucumber`를 처음 사용 해보게 되었는데, 
인수테스트 코드의 관리가 상당히 편하다고 느껴졌고, 
자연어로 작성 된 테스트 코드를 읽는 것 만으로도 비즈니스 로직을 충분히 이해할 수 있다는 점이 큰 장점으로 느껴졌습니다.

## 아키텍처

도메인 별로 패키지를 나누어 사용하였습니다.
외부 변경 사항(비즈니스 로직 실행 트리거, 영속화 방식 등)으로 인한 사이드 이펙트를 줄이고자 했습니다.

<img width="624" alt="image" src="https://github.com/green-kong/musinsa-assignment/assets/96301958/80467df2-8def-46e0-9c10-d4730f1acc63">


간략화 해서 그린 브랜드의 클래스 다이어그램 입니다.
전체적으로 의존성이 외부로 흘러나가지 않게끔 설계하였습니다.
이로 인해 외부환경의 변화에 유연하게 대처할 수 있습니다.

도메인 패키지간의 의존성을 제거하여, 다른 도메인의 변경으로 인한 사이드 이펙트를 줄이기 위해 노력하였습니다.

<img width="608" alt="image" src="https://github.com/green-kong/musinsa-assignment/assets/96301958/c8c3326c-7a1e-4f34-86f2-2491200fbc19">


IntelliJ의 Depedency Matrix를 활용하여 도메인 패키지간 의존성을 확인하였습니다.
모든 의존성이 common 패키지를 향하고 있고,
common 패키지는 다른 패키지를 의존하지 않고 있습니다.

## 데이터 베이스

<img width="673" alt="image" src="https://github.com/green-kong/musinsa-assignment/assets/96301958/63c49d41-e2ab-4453-9e6d-57287859141f">


테스트의 용이성과 FK를 사용하지 않았습니다.  
FK를 통해 무결성을 맞추기 보다, 도메인을 통해 데이터 무결성을 맞추려 노력했습니다.  

```sql
create index highest_idx_category_id on highest_price_informations (category_id)
    
create index highest_idx_brand_id on highest_price_informations (brand_id);
    
create index lowest_idx_category_id on lowest_price_informations (category_id);
    
create index lowest_idx_brand_id on lowest_price_informations (brand_id)
    
create index lowest_idx_brand_id_category_id 
    on lowest_price_informations (brand_id, category_id)
    
create index product_idx_brandId_categoryId on products (brand_id, category_id)
```

카테고리의 이름과 브랜드의 이름은 unique 설정을 통해 인덱스를 이용합니다.


## 프론트

리액트를 사용해 본 경험이 있어 리액트와 타입스크립트로 프론트를 작업했습니다.
리액트 사용 경험이 많지 않고, 기술 이해도가 깊지 않아 정상적으로 동작하게 만드는 것에 집중했습니다.
